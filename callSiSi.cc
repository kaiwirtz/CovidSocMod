// C++ Code automatically generated by 'XSiSi 2.0'
// Emitted at Sun Feb 07 08:50:23 CET 2021

// Please read the documentation!

#include "callSiSi.hh"

// Declaration of parameters and variables of simulation:
  double Time;
  double TimeStart;
  double TimeEnd;
  double TimeStep;
  double OutputStep;
  long RandomInit;
  double** Conc;
  unsigned int RowsOfConc;
  unsigned int ColumnsOfConc;
  String*      HeadOfConc;
  double** trans;
  unsigned int RowsOftrans;
  unsigned int ColumnsOftrans;
  String*      HeadOftrans;
  double** aRtrans;
  unsigned int RowsOfaRtrans;
  unsigned int ColumnsOfaRtrans;
  String*      HeadOfaRtrans;
  double* exposition;
  unsigned int LengthOfexposition;
  double* CostAcc;
  unsigned int LengthOfCostAcc;
  String MovieResFile;
  String VarResFile;
  String VarIndexFile;
  long VarActive;
  long NumDice;
  long MonteCarlo;
  long VarOutputStep;
  long AnalysisType;
  long** parindex;
  unsigned int RowsOfparindex;
  unsigned int ColumnsOfparindex;
  String*      HeadOfparindex;
  long DataActive;
  long DataCountryIndex;
  double critfatal;
  double* err_data_weights;
  unsigned int LengthOferr_data_weights;
  double data_off_tim;
  long Experiment;
  long* IndExp;
  unsigned int LengthOfIndExp;
  double storetim;
  double Zero;
  double mindelt;
  double maxdelt;
  double relrate;
  double relchange;
  double accuracy;
  long method;
  double InfectDens;
  double* age_dist;
  unsigned int LengthOfage_dist;
  double init_age;
  double m_age;
  double* med_ages;
  unsigned int LengthOfmed_ages;
  double* temp_min;
  unsigned int LengthOftemp_min;
  double* temp_max;
  unsigned int LengthOftemp_max;
  double* latitude;
  unsigned int LengthOflatitude;
  double* excessm;
  unsigned int LengthOfexcessm;
  double* houseold;
  unsigned int LengthOfhouseold;
  double time_shut;
  double period_vacc;
  double vacc_frac;
  double** ForcData;
  unsigned int RowsOfForcData;
  unsigned int ColumnsOfForcData;
  String*      HeadOfForcData;
  double beta_max;
  double recov;
  double mort;
  double sub_beta;
  double social;
  double catchup;
  double acc_catch;
  double tlag;
  double flexibility;
  double behave;
  double behave_rate;
  double temp_ampl;
  double weekampl_sub;
  double week_ampl;
  double sun_ampl;
  double temp_width;
  double q10_fatal;
  double* attack;
  unsigned int LengthOfattack;
  double relaxs;
  double travel;
  double DecStart;
  double parvar1;
  double parvar2;
  double** data;
  unsigned int RowsOfdata;
  unsigned int ColumnsOfdata;
  String*      HeadOfdata;

// Declaration of additional output variables:

  double *VAR_VAL[199];
  char VAR_NAMES[199][22];
  int num_variat_parser;

// The compilers need the delcaration of static variables:
  String       SiSi::SimulationName;   // Full name of the simulation.
  String       SiSi::ModelName;        // Full name of the model.
  String       SiSi::ModelPath;        // Path of the executable model.
  TwoWayList*  SiSi::IncludeFiles;     // Names of all included files.
  TwoWayList*  SiSi::OutputVariables;  // Includes all output variables.
  TwoWayList*  SiSi::VariationVariables;  // Includes all output variables.
  LogFile      SiSi::logFile;          // The file for Job controlling system.
  ResultWriter SiSi::resultWriter;     // Declaration of ResultWriter.
  String       SiSi::resultFilename;   // Name of the result file.
  String       SiSi::simulationPath;   // Path of the simulation file.

/////////////////////////////////////////////////////////////////////////////
//
// public methods:
//
/////////////////////////////////////////////////////////////////////////////

bool SiSi::parseSimulation(int argc, char* argv[])
{
  if (argc == 1) {                   // --- no file spcified ---
    cerr << "*** Please specify an input file!\n"
         << "*** Sorry, no output :-(\n";
    return false;
  }
  return parseSimulation(argv[1], argv[0]);
}
bool SiSi::parseSimulation(const char* simulationFile, const char* program)
{
  TwoWayList list;                   // List of parameters and variables.
  TwoWayList tempList;               // List of all output variables in list.
  TwoWayListElement* el;             // Pointer to TwoWayListElement.
  Parameter* par;                    // Pointer to Parameter.
  ResultElement* resultElement;      // Pointer to ResultElement.
  SiSiParser parser;                 // The SiSi parser.
  String message;                    // For messages.
  bool result = true;                // Result of function.

  String pathWithoutSuffix
    = FilenameHandling::getPathWithoutSuffix(simulationFile);
  simulationPath = FilenameHandling::getName(simulationFile);
  resultFilename = pathWithoutSuffix + ".res";
  resultWriter.setFilename(resultFilename);
  MessageHandler::setBaseFilename(pathWithoutSuffix);
  logFile.initialize(pathWithoutSuffix, program); // Initialize log file

  // Parse simulation parameters:
  message = parser.parseSimulation(list, simulationFile);
  if( message.compareTo("OK") != 0 ) {           // Does an error occur?.
    MessageHandler::error(message);
    MessageHandler::error("Sorry, no output :-(");
    abort();
    return false;                                // An error occurs! :-(
  }

  ///////////////////////////////////////////////////////////////////////////
  //
  // Gets all parameters:
  //
  el = list.getElement("IncludeFiles");
  if( el && el->isFromClass("ListParameter") ) {
    if( ((ListParameter*) el)->getTypeOfElements() == ParameterType::STRING )
      IncludeFiles = ((ListParameter*) el)->getValue();
    else {
      MessageHandler::error("The list \"IncludeFiles\" doesn't contain strings!");
      result = false;
    }
  }
  else {
    IncludeFiles = new TwoWayList(); 
    MessageHandler::error("'list IncludeFiles' not found!?!");
    result = false;
  }

  el = list.getElement("OutputVariables");
  if( el && el->isFromClass("ListParameter") ) {
    if( ((ListParameter*) el)->getTypeOfElements() == ParameterType::PARAMETER )
      OutputVariables = ((ListParameter*) el)->getValue();
    else {
      MessageHandler::error("The list \"OutputVariables\" doesn't contain parameters!");
      result = false;
    }
  }
  else {
    OutputVariables = new TwoWayList(); 
    MessageHandler::error("'list OutputVariables' not found!?!");
    result = false;
  }

  el = list.getElement("VariationVariables");
  if( el && el->isFromClass("ListParameter") ) {
    if( ((ListParameter*) el)->getTypeOfElements() == ParameterType::PARAMETER )
      VariationVariables = ((ListParameter*) el)->getValue();
    else {
      MessageHandler::error("The list \"VariationVariables\" doesn't contain parameters!");
      result = false;
    }
  }
  else {
    VariationVariables = new TwoWayList(); 
    MessageHandler::error("'list VariationVariables' not found!?!");
    result = false;
  }

  el = list.getElement("Conc");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(Conc);
    HeadOfConc    = ((ArrayParameter*) el)->getHead();
    RowsOfConc    = ((ArrayParameter*) el)->getNumberOfRows();
    ColumnsOfConc = ((ArrayParameter*) el)->getNumberOfColumns();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( Conc == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array Conc' not found!?!");
    result = false;
  }

  el = list.getElement("trans");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(trans);
    HeadOftrans    = ((ArrayParameter*) el)->getHead();
    RowsOftrans    = ((ArrayParameter*) el)->getNumberOfRows();
    ColumnsOftrans = ((ArrayParameter*) el)->getNumberOfColumns();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( trans == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array trans' not found!?!");
    result = false;
  }

  el = list.getElement("aRtrans");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(aRtrans);
    HeadOfaRtrans    = ((ArrayParameter*) el)->getHead();
    RowsOfaRtrans    = ((ArrayParameter*) el)->getNumberOfRows();
    ColumnsOfaRtrans = ((ArrayParameter*) el)->getNumberOfColumns();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( aRtrans == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array aRtrans' not found!?!");
    result = false;
  }

  el = list.getElement("exposition");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(exposition);
    LengthOfexposition = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( exposition == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array exposition' not found!?!");
    result = false;
  }

  el = list.getElement("CostAcc");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(CostAcc);
    LengthOfCostAcc = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( CostAcc == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array CostAcc' not found!?!");
    result = false;
  }

  el = list.getElement("parindex");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(parindex);
    HeadOfparindex    = ((ArrayParameter*) el)->getHead();
    RowsOfparindex    = ((ArrayParameter*) el)->getNumberOfRows();
    ColumnsOfparindex = ((ArrayParameter*) el)->getNumberOfColumns();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( parindex == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array parindex' not found!?!");
    result = false;
  }

  el = list.getElement("err_data_weights");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(err_data_weights);
    LengthOferr_data_weights = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( err_data_weights == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array err_data_weights' not found!?!");
    result = false;
  }

  el = list.getElement("IndExp");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(IndExp);
    LengthOfIndExp = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( IndExp == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array IndExp' not found!?!");
    result = false;
  }

  el = list.getElement("age_dist");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(age_dist);
    LengthOfage_dist = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( age_dist == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array age_dist' not found!?!");
    result = false;
  }

  el = list.getElement("med_ages");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(med_ages);
    LengthOfmed_ages = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( med_ages == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array med_ages' not found!?!");
    result = false;
  }

  el = list.getElement("temp_min");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(temp_min);
    LengthOftemp_min = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( temp_min == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array temp_min' not found!?!");
    result = false;
  }

  el = list.getElement("temp_max");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(temp_max);
    LengthOftemp_max = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( temp_max == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array temp_max' not found!?!");
    result = false;
  }

  el = list.getElement("latitude");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(latitude);
    LengthOflatitude = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( latitude == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array latitude' not found!?!");
    result = false;
  }

  el = list.getElement("excessm");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(excessm);
    LengthOfexcessm = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( excessm == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array excessm' not found!?!");
    result = false;
  }

  el = list.getElement("houseold");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(houseold);
    LengthOfhouseold = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( houseold == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array houseold' not found!?!");
    result = false;
  }

  el = list.getElement("ForcData");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(ForcData);
    HeadOfForcData    = ((ArrayParameter*) el)->getHead();
    RowsOfForcData    = ((ArrayParameter*) el)->getNumberOfRows();
    ColumnsOfForcData = ((ArrayParameter*) el)->getNumberOfColumns();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( ForcData == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array ForcData' not found!?!");
    result = false;
  }

  el = list.getElement("attack");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(attack);
    LengthOfattack = ((ArrayParameter*) el)->getNumberOfRows();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( attack == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array attack' not found!?!");
    result = false;
  }

  el = list.getElement("data");
  if( el && el->isFromClass("ArrayParameter") ) {
    message = ((ArrayParameter*) el)->getArray(data);
    HeadOfdata    = ((ArrayParameter*) el)->getHead();
    RowsOfdata    = ((ArrayParameter*) el)->getNumberOfRows();
    ColumnsOfdata = ((ArrayParameter*) el)->getNumberOfColumns();
    if( message.compareTo("OK") != 0 )
      MessageHandler::error(message);
    if( data == NULL )
      result = false;
  }
  else {
    MessageHandler::error("'array data' not found!?!");
    result = false;
  }

// lists of doubles, strings and longs ...
struct ParDoubleElem{ char parname[22]; double *paraddr; char test; };
struct ParStringElem{ char parname[22]; String *paraddr; char test; };
struct ParLongElem{ char parname[22]; long *paraddr; char test; };

int i;
String errorstr;
struct ParDoubleElem parDlist[43]={{"Time",&Time},{"TimeStart",&TimeStart},{"TimeEnd",&TimeEnd},{"TimeStep",&TimeStep},{"OutputStep",&OutputStep},{"critfatal",&critfatal},{"data_off_tim",&data_off_tim},{"storetim",&storetim},{"Zero",&Zero},{"mindelt",&mindelt},{"maxdelt",&maxdelt},{"relrate",&relrate},{"relchange",&relchange},{"accuracy",&accuracy},{"InfectDens",&InfectDens},{"init_age",&init_age},{"m_age",&m_age},{"time_shut",&time_shut},{"period_vacc",&period_vacc},{"vacc_frac",&vacc_frac},{"beta_max",&beta_max},{"recov",&recov},{"mort",&mort},{"sub_beta",&sub_beta},{"social",&social},{"catchup",&catchup},{"acc_catch",&acc_catch},{"tlag",&tlag},{"flexibility",&flexibility},{"behave",&behave},{"behave_rate",&behave_rate},{"temp_ampl",&temp_ampl},{"weekampl_sub",&weekampl_sub},{"week_ampl",&week_ampl},{"sun_ampl",&sun_ampl},{"temp_width",&temp_width},{"q10_fatal",&q10_fatal},{"relaxs",&relaxs},{"travel",&travel},{"DecStart",&DecStart},{"parvar1",&parvar1},{"parvar2",&parvar2},{"END"}};
struct ParLongElem parLlist[11]={{"RandomInit",&RandomInit},{"VarActive",&VarActive},{"NumDice",&NumDice},{"MonteCarlo",&MonteCarlo},{"VarOutputStep",&VarOutputStep},{"AnalysisType",&AnalysisType},{"DataActive",&DataActive},{"DataCountryIndex",&DataCountryIndex},{"Experiment",&Experiment},{"method",&method},{"END"}};
struct ParStringElem parSlist[7]={{"SimulationName",&SimulationName},{"ModelName",&ModelName},{"ModelPath",&ModelPath},{"MovieResFile",&MovieResFile},{"VarResFile",&VarResFile},{"VarIndexFile",&VarIndexFile},{"END"}};

 /////////////////////////////////////////////////
 // Input Loop over all pars of same type
 for(i=0;strstr(parDlist[i].parname,"END") == NULL ;i++)
  {
  el = list.getElement(parDlist[i].parname);
  if( el && el->isFromClass("FloatParameter") )
    *parDlist[i].paraddr= ((FloatParameter*) el)->getValue();
  else
    {
    strcpy(errorstr,parDlist[i].parname);
    strcat(errorstr," not found!!!");
    MessageHandler::error(errorstr); 
    result = false;
    }
  }

 /////////////////////////////////////////////////
 // Input Loop over all pars of same type
 for(i=0;strstr(parSlist[i].parname,"END") == NULL ;i++)
  {
  el = list.getElement(parSlist[i].parname);
  if( el && el->isFromClass("StringParameter") )
    *parSlist[i].paraddr= ((StringParameter*) el)->getValue();
  else
    {
    strcpy(errorstr,parSlist[i].parname);
    strcat(errorstr," not found!!!");
    MessageHandler::error(errorstr); 
    result = false;
    }
  }

 /////////////////////////////////////////////////
 // Input Loop over all pars of same type
 for(i=0;strstr(parLlist[i].parname,"END") == NULL ;i++)
  {
  el = list.getElement(parLlist[i].parname);
  if( el && el->isFromClass("IntParameter") )
    *parLlist[i].paraddr= ((IntParameter*) el)->getValue();
  else
    {
    strcpy(errorstr,parLlist[i].parname);
    strcat(errorstr," not found!!!");
    MessageHandler::error(errorstr); 
    result = false;
    }
  }
struct ParDoubleElem parVlist[29]={{"InfectDens",&InfectDens},{"init_age",&init_age},{"m_age",&m_age},{"time_shut",&time_shut},{"period_vacc",&period_vacc},{"vacc_frac",&vacc_frac},{"beta_max",&beta_max},{"recov",&recov},{"mort",&mort},{"sub_beta",&sub_beta},{"social",&social},{"catchup",&catchup},{"acc_catch",&acc_catch},{"tlag",&tlag},{"flexibility",&flexibility},{"behave",&behave},{"behave_rate",&behave_rate},{"temp_ampl",&temp_ampl},{"weekampl_sub",&weekampl_sub},{"week_ampl",&week_ampl},{"sun_ampl",&sun_ampl},{"temp_width",&temp_width},{"q10_fatal",&q10_fatal},{"relaxs",&relaxs},{"travel",&travel},{"DecStart",&DecStart},{"parvar1",&parvar1},{"parvar2",&parvar2},{"END"}};

 /////////////////////////////////////////////////
 // Input Loop over all pars of same type
 for(i=0;strstr(parVlist[i].parname,"END") == NULL ;i++)
  {
  strcpy(VAR_NAMES[i],parVlist[i].parname);
  VAR_VAL[i] = parVlist[i].paraddr;
  }
  num_variat_parser = 28;
  ///////////////////////////////////////////////////////////////////////////
  //
  // Puts active output variables to result list and deletes tempList:
  //
  while( (resultElement=(ResultElement*) tempList.removeFirstElement())
	 != NULL ) {
    el = OutputVariables->getElement( resultElement->getName() );
    if( el && el->isFromClass("ResultParameter") ) {
      if( ((ResultParameter*) el)->isActive() ) {
	resultElement->setPrecision( ((ResultParameter*) el)->getPrecision() );
	resultWriter.appendElement(resultElement);
      }
      else
	delete resultElement; // Not needed anymore.
    }
  }

  ///////////////////////////////////////////////////////////////////////////
  //
  // Appends additional output variables to result list:
  //

  ///////////////////////////////////////////////////////////////////////////
  //
  // Deletes parameter list:
  //
  while( (el=(Parameter*) list.removeFirstElement()) != NULL )
    delete el;

  ///////////////////////////////////////////////////////////////////////////
  //
  // Does an error occur?
  //
  if( !result ) {
    cerr << "*** Something is wrong in the simulation files!\n"
         << "*** Please read the file '" << pathWithoutSuffix + ".err"
         << "' for details!\n"
         << "*** Sorry, no output :-(\n";
    abort();
  }
  resultWriter.setTimeStep(OutputStep);    // Set time step of output.
  Random::initialize(RandomInit);          // Initialize random generator.
  return result;
}

/////////////////////////////////////////////////////////////////////////////
//
// private methods:
//
/////////////////////////////////////////////////////////////////////////////

void SiSi::abort() {
  SiSi::resultWriter.close();              // Closes result file.
  SiSi::logFile.abort();                   // Toggle status to aborted.
  MessageHandler::finalize();              // Closes opened message files.
}
void SiSi::finalize() {
  SiSi::resultWriter.close();              // Closes result file.
  SiSi::logFile.finish();                  // Toggle status to finished.
  MessageHandler::finalize();              // Closes opened message files.
}

